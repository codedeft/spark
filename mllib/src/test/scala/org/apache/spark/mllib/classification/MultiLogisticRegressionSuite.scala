/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.mllib.classification


import org.scalatest.BeforeAndAfterAll
import org.scalatest.FunSuite
import org.scalatest.matchers.ShouldMatchers

import org.apache.spark.SparkContext
import org.apache.spark.rdd.RDD
import org.apache.spark.mllib.regression.LabeledPoint
//import org.apache.spark.mllib.classification.MultiLogisticRegressionWithNewton

class MultiLogisticRegressionSuite extends FunSuite with BeforeAndAfterAll with ShouldMatchers {
  def error(actual: Double, expected: Double): Double = {
    math.abs((actual - expected) / expected)
  }

  @transient private var sc: SparkContext = _

  var rddData: RDD[LabeledPoint] = _
  var model: MultiLogisticRegressionModel = _
  val epsilon: Double = 0.001

  override def beforeAll() {
    sc = new SparkContext("local", "test")

    /**
     * This dataset is generated by R with the following command
     *
     * set.seed(1)
     * n <- 1000
     * data <- data.frame(x1 = runif(n,0,100), x2 = runif(n,0,100))
     * data <- transform(data, y = 1 + ifelse(100 - x1 - x2 + rnorm(n, sd = 20) < 0, 0,
     * ifelse(100 - 2 * x2 + rnorm(n, sd = 20) < 0, 1, 2)))
     */
    val file = this.getClass.getResource("/classification/MultiLogisticRegressionTest.data").toURI.toString
    rddData = sc.textFile(file).map(line => {
      val temp = line.toString.split(",")
      val y = temp(3) match {
        case "1" => 0.0
        case "2" => 1.0
        case _ => 2.0
      }
      val x = temp.slice(1, 3).map(_.toDouble)
      LabeledPoint(y, x)
    })

    /**
     * model is built in R by model <- multinom(formula = y ~ ., data = data, Hess = T, model = TRUE)
     * ps, baseline is always class 0, so no weights for the first class.
     *
     * Coefficients:
     * (Intercept)          x1         x2
     * 2    4.459949 -0.08434255 -0.0329027
     * 3   10.597657 -0.09626916 -0.1456645
     *
     * Std. Errors:
     * (Intercept)          x1          x2
     * 2   0.6100089 0.006820330 0.006787469
     * 3   0.7133052 0.007306844 0.009754495
     *
     * Residual Deviance: 850.8595
     * AIC: 862.8595
     */
    model = new MultiLogisticRegressionModel(
      Array(
        4.4599490, -0.08434255, -0.0329027,
        10.597657, -0.09626916, -0.1456645
      ), 3
    )
  }

  override def afterAll() {
    sc.stop()
    System.clearProperty("spark.driver.port")
  }

  def validatePrediction(predictions: Seq[Double], input: Seq[LabeledPoint]) {
    val numOffPredictions = predictions.zip(input).filter {
      case (prediction, expected) =>
        (prediction != expected.label)
    }.size
    // At least 83% of the predictions should be on.
    ((input.length - numOffPredictions).toDouble / input.length) should be > 0.83
  }

  // Test if the MultiLogisticRegressionModel can return correct probabilities and prediction.
  test("multinomial logistic regression model") {

    assert(model.classes == 3, "# of classes should be 3")

    // The probability can be returned in R by
    // predict(model, type = "probs", data.frame(x1 = 39.8645696 , x2 = 30.93474982))

    val localData = rddData.toArray()

    // predict(model, type = "probs", data[23,])
    val probs0 = model.predictProbabilities(localData(22).features)
    val pred0 = model.predict(localData(22).features)
    assert(error(probs0(0), 0.14027968) < epsilon)
    assert(error(probs0(1), 0.02800887) < epsilon)
    assert(error(probs0(2), 0.83171145) < epsilon)
    assert(math.round(pred0) == 2, "pred0 should be class 2")

    val probs1 = model.predictProbabilities(localData(985).features)
    val pred1 = model.predict(localData(985).features)
    assert(error(probs1(0), 0.4482794) < epsilon)
    assert(error(probs1(1), 0.1713976) < epsilon)
    assert(error(probs1(2), 0.3803230) < epsilon)
    assert(math.round(pred1) == 0, "pred1 should be class 0")

    val probs2 = model.predictProbabilities(localData(836).features)
    val pred2 = model.predict(localData(836).features)
    assert(error(probs2(0), 0.04987734) < epsilon)
    assert(error(probs2(1), 0.41692698) < epsilon)
    assert(error(probs2(2), 0.53319568) < epsilon)
    assert(math.round(pred2) == 2, "pred2 should be class 2")

    // Test RDD input
    val rddProbs = model.predictProbabilities(rddData.map(_.features)).toArray()
    val rddPreds = model.predict(rddData.map(_.features)).toArray()

    assert(error(rddProbs(22)(0), 0.14027968) < epsilon)
    assert(error(rddProbs(22)(1), 0.02800887) < epsilon)
    assert(error(rddProbs(22)(2), 0.83171145) < epsilon)
    assert(math.round(rddPreds(22)) == 2, "pred0 should be class 2")

    assert(error(rddProbs(985)(0), 0.4482794) < epsilon)
    assert(error(rddProbs(985)(1), 0.1713976) < epsilon)
    assert(error(rddProbs(985)(2), 0.3803230) < epsilon)
    assert(math.round(rddPreds(985)) == 0, "pred1 should be class 0")

    assert(error(rddProbs(836)(0), 0.04987734) < epsilon)
    assert(error(rddProbs(836)(1), 0.41692698) < epsilon)
    assert(error(rddProbs(836)(2), 0.53319568) < epsilon)
    assert(math.round(rddPreds(836)) == 2, "pred2 should be class 2")
  }

  // Test if we can correctly learn MLOR from rddData.
  test("training logistic regression using rddData") {

//    val localModel = MultiLogisticRegressionWithNewton.train(rddData, 3, 10)
//
//    for (i <- 0 until localModel.weights.length) {
//      assert(error(localModel.intercepts(i), model.intercepts(i)) < epsilon,
//        "weights should be the same as the one built in R")
//    }
  }
}